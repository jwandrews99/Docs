{"remainingRequest":"/Users/jack/Documents/GitHub/Docs/node_modules/babel-loader/lib/index.js??ref--7-1!/Users/jack/Documents/GitHub/Docs/node_modules/@docusaurus/mdx-loader/src/index.js??ref--7-2!/Users/jack/Documents/GitHub/Docs/node_modules/@docusaurus/plugin-content-docs/lib/markdown/index.js??ref--7-3!/Users/jack/Documents/GitHub/Docs/docs/js/adva/promises.md","dependencies":[{"path":"/Users/jack/Documents/GitHub/Docs/docs/js/adva/promises.md","mtime":1585344082007},{"path":"/Users/jack/Documents/GitHub/Docs/.docusaurus/docusaurus-plugin-content-docs/site-docs-js-adva-promises-md-eb5.json","mtime":1585344343504},{"path":"/Users/jack/Documents/GitHub/Docs/node_modules/cache-loader/dist/cjs.js","mtime":1585256602861},{"path":"/Users/jack/Documents/GitHub/Docs/node_modules/babel-loader/lib/index.js","mtime":1585256602734},{"path":"/Users/jack/Documents/GitHub/Docs/node_modules/@docusaurus/mdx-loader/src/index.js","mtime":1585256621747},{"path":"/Users/jack/Documents/GitHub/Docs/node_modules/@docusaurus/plugin-content-docs/lib/markdown/index.js","mtime":1585256618966}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9leHRlbmRzIGZyb20iL1VzZXJzL2phY2svRG9jdW1lbnRzL0dpdEh1Yi9Eb2NzL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzIjtpbXBvcnQgUmVhY3QgZnJvbSdyZWFjdCc7aW1wb3J0e21keH1mcm9tJ0BtZHgtanMvcmVhY3QnO2V4cG9ydCBjb25zdCBmcm9udE1hdHRlcj17fTtleHBvcnQgY29uc3QgbWV0YWRhdGE9eyJpZCI6ImpzL2FkdmEvcHJvbWlzZXMiLCJ0aXRsZSI6InByb21pc2VzIiwiZGVzY3JpcHRpb24iOiIjIFByb21pc2VzIGluIEpzIiwic291cmNlIjoiQHNpdGUvZG9jcy9qcy9hZHZhL3Byb21pc2VzLm1kIiwicGVybWFsaW5rIjoiL2RvY3MvanMvYWR2YS9wcm9taXNlcyJ9Oy8qIEBqc3ggbWR4ICovZXhwb3J0IGNvbnN0IHJpZ2h0VG9jPVtdO2NvbnN0IG1ha2VTaG9ydGNvZGU9bmFtZT0+ZnVuY3Rpb24gTURYRGVmYXVsdFNob3J0Y29kZShwcm9wcyl7Y29uc29sZS53YXJuKCJDb21wb25lbnQgIituYW1lKyIgd2FzIG5vdCBpbXBvcnRlZCwgZXhwb3J0ZWQsIG9yIHByb3ZpZGVkIGJ5IE1EWFByb3ZpZGVyIGFzIGdsb2JhbCBzY29wZSIpO3JldHVybiBtZHgoImRpdiIscHJvcHMpO307Y29uc3QgbGF5b3V0UHJvcHM9e3JpZ2h0VG9jfTtjb25zdCBNRFhMYXlvdXQ9IndyYXBwZXIiO2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoe2NvbXBvbmVudHMsLi4ucHJvcHN9KXtyZXR1cm4gbWR4KE1EWExheW91dCxfZXh0ZW5kcyh7fSxsYXlvdXRQcm9wcyxwcm9wcyx7Y29tcG9uZW50czpjb21wb25lbnRzLG1keFR5cGU6Ik1EWExheW91dCJ9KSxtZHgoImgxIix7ImlkIjoicHJvbWlzZXMtaW4tanMifSxgUHJvbWlzZXMgaW4gSnNgKSxtZHgoInAiLG51bGwsYEFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gaXMgb25lIHRoYXQgYWxsb3dzIHRoZSBjb21wdXRlciB0byDigJxtb3ZlIG9u4oCdIHRvIG90aGVyIHRhc2tzIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBhc3luY2hyb25vdXMgb3BlcmF0aW9uIHRvIGNvbXBsZXRlLiBBc3luY2hyb25vdXMgcHJvZ3JhbW1pbmcgbWVhbnMgdGhhdCB0aW1lLWNvbnN1bWluZyBvcGVyYXRpb25zIGRvbuKAmXQgaGF2ZSB0byBicmluZyBldmVyeXRoaW5nIGVsc2UgaW4gb3VyIHByb2dyYW1zIHRvIGEgaGFsdC5gKSxtZHgoInAiLG51bGwsYE9wZXJhdGlvbnMgbGlrZSBtYWtpbmcgYSBuZXR3b3JrIHJlcXVlc3Qgb3IgcXVlcnlpbmcgYSBkYXRhYmFzZSBjYW4gYmUgdGltZS1jb25zdW1pbmcsIGJ1dCBKYXZhU2NyaXB0IGFsbG93cyB1cyB0byBleGVjdXRlIG90aGVyIHRhc2tzIHdoaWxlIGF3YWl0aW5nIHRoZWlyIGNvbXBsZXRpb24uYCksbWR4KCJoMSIseyJpZCI6IndoYXQtaXMtcHJvbWlzZSJ9LGBXaGF0IGlzIHByb21pc2U/YCksbWR4KCJwIixudWxsLGBQcm9taXNlcyBhcmUgb2JqZWN0cyB0aGF0IHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgb3V0Y29tZSBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLmApLG1keCgicCIsbnVsbCxgVGhleSBjb21lIGluIHRocmVlIGZvcm1zOiBQZW5kaW5nIC8gZnVyZmlsbGVkIC8gcmVqZWN0ZWRgKSxtZHgoInAiLG51bGwsYFBlbmRpbmc6IFRoZSBpbml0aWFsIHN0YXRl4oCUIHRoZSBvcGVyYXRpb24gaGFzIG5vdCBjb21wbGV0ZWQgeWV0LmApLG1keCgicCIsbnVsbCxgRnVsZmlsbGVkOiBUaGUgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGFuZCB0aGUgcHJvbWlzZSBub3cgaGFzIGEgcmVzb2x2ZWQgdmFsdWUuIEZvciBleGFtcGxlLCBhIHJlcXVlc3TigJlzIHByb21pc2UgbWlnaHQgcmVzb2x2ZSB3aXRoIGEgSlNPTiBvYmplY3QgYXMgaXRzIHZhbHVlLmApLG1keCgicCIsbnVsbCxgUmVqZWN0ZWQ6IFRoZSBvcGVyYXRpb24gaGFzIGZhaWxlZCBhbmQgdGhlIHByb21pc2UgaGFzIGEgcmVhc29uIGZvciB0aGUgZmFpbHVyZS4gVGhpcyByZWFzb24gaXMgdXN1YWxseSBhbiBFcnJvciBvZiBzb21lIGtpbmQuYCksbWR4KCJoMSIseyJpZCI6ImNvbnN0cnVjdGluZy1hLXByb21pc2Utb2JqZWN0In0sYENvbnN0cnVjdGluZyBhIHByb21pc2UgT2JqZWN0YCksbWR4KCJwIixudWxsLGBUbyBjcmVhdGUgYSBuZXcgUHJvbWlzZSBvYmplY3QsIHdlIHVzZSB0aGUgbmV3IGtleXdvcmQgYW5kIHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIG1ldGhvZC5gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYGNvbnN0IGV4ZWN1dG9yRnVuY3Rpb24gPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7IH07CmNvbnN0IG15Rmlyc3RQcm9taXNlID0gbmV3IFByb21pc2UoZXhlY3V0b3JGdW5jdGlvbik7CmApKSxtZHgoInAiLG51bGwsYFRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIG1ldGhvZCB0YWtlcyBhIGZ1bmN0aW9uIHBhcmFtZXRlciBjYWxsZWQgdGhlIGV4ZWN1dG9yIGZ1bmN0aW9uIHdoaWNoIHJ1bnMgYXV0b21hdGljYWxseSB3aGVuIHRoZSBjb25zdHJ1Y3RvciBpcyBjYWxsZWQuIFRoZSBleGVjdXRvciBmdW5jdGlvbiBnZW5lcmFsbHkgc3RhcnRzIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gYW5kIGRpY3RhdGVzIGhvdyB0aGUgcHJvbWlzZSBzaG91bGQgYmUgc2V0dGxlZC5gKSxtZHgoImgxIix7ImlkIjoiYW4tZXhhbXBsZS1leGVjdXRvci1mdW5jdGlvbi1pbi1hLXByb21pc2UtY29uc3RydWN0b3IifSxgQW4gZXhhbXBsZSBleGVjdXRvciBmdW5jdGlvbiBpbiBhIFByb21pc2UgY29uc3RydWN0b3JgKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYGNvbnN0IGV4ZWN1dG9yRnVuY3Rpb24gPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgaWYgKHNvbWVDb25kaXRpb24pIHsKICAgICAgcmVzb2x2ZSgnSSByZXNvbHZlZCEnKTsKICB9IGVsc2UgewogICAgICByZWplY3QoJ0kgcmVqZWN0ZWQhJyk7IAogIH0KfQpjb25zdCBteUZpcnN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGV4ZWN1dG9yRnVuY3Rpb24pOwpgKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBjb25zdCBpbnZlbnRvcnkgPSB7CiAgc3VuZ2xhc3NlczogMTkwMCwKICBwYW50czogMTA4OCwKICBiYWdzOiAxMzQ0Cn07CgovLyBXcml0ZSB5b3VyIGNvZGUgYmVsb3c6CmNvbnN0IG15RXhlY3V0b3IgPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgaWYgKGludmVudG9yeS5zdW5nbGFzc2VzID4gMCkgewogICAgcmVzb2x2ZSgnU3VuZ2xhc3NlcyBvcmRlciBwcm9jZXNzZWQuJyk7CiAgfSBlbHNlIHsKICAgIHJlamVjdCgnVGhhdCBpdGVtIGlzIHNvbGQgb3V0LicpOwogIH0KfQoKY29uc3Qgb3JkZXJTdW5nbGFzc2VzID0gKCkgPT4gbmV3IFByb21pc2UobXlFeGVjdXRvcik7CmNvbnN0IG9yZGVyUHJvbWlzZSA9IG9yZGVyU3VuZ2xhc3NlcygpOwoKY29uc29sZS5sb2cob3JkZXJQcm9taXNlKTsKYCkpLG1keCgiaDEiLHsiaWQiOiJ0aGUtbm9kZS1zZXR0aW1lb3V0LWZ1bmN0aW9uIn0sYFRoZSBOb2RlIHNldFRpbWVvdXQoKSBGdW5jdGlvbmApLG1keCgicCIsbnVsbCxgS25vd2luZyBob3cgdG8gY29uc3RydWN0IGEgcHJvbWlzZSBpcyB1c2VmdWwsIGJ1dCBtb3N0IG9mIHRoZSB0aW1lLCBrbm93aW5nIGhvdyB0byBjb25zdW1lLCBvciB1c2UsIHByb21pc2VzIHdpbGwgYmUga2V5LiBSYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgcHJvbWlzZXMsIHlvdeKAmWxsIGJlIGhhbmRsaW5nIFByb21pc2Ugb2JqZWN0cyByZXR1cm5lZCB0byB5b3UgYXMgdGhlIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVzZSBwcm9taXNlcyB3aWxsIHN0YXJ0IG9mZiBwZW5kaW5nIGJ1dCBzZXR0bGUgZXZlbnR1YWxseS5gKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LGBzZXRUaW1lb3V0KClgKSxgIGlzIGEgTm9kZSBBUEkgKGEgY29tcGFyYWJsZSBBUEkgaXMgcHJvdmlkZWQgYnkgd2ViIGJyb3dzZXJzKSB0aGF0IHVzZXMgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIHNjaGVkdWxlIHRhc2tzIHRvIGJlIHBlcmZvcm1lZCBhZnRlciBhIGRlbGF5LiBzZXRUaW1lb3V0KCkgaGFzIHR3byBwYXJhbWV0ZXJzOiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBhIGRlbGF5IGluIG1pbGxpc2Vjb25kc2ApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgY29uc3QgZGVsYXllZEhlbGxvID0gKCkgPT4gewogIGNvbnNvbGUubG9nKCdIaSEgVGhpcyBpcyBhbiBhc3luY2hyb25vdXMgZ3JlZXRpbmchJyk7Cn07CgpzZXRUaW1lb3V0KGRlbGF5ZWRIZWxsbywgMjAwMCk7CmApKSxtZHgoInAiLG51bGwsYFRoaXMgZGVsYXkgaXMgcGVyZm9ybWVkIGFzeW5jaHJvbm91c2x54oCUdGhlIHJlc3Qgb2Ygb3VyIHByb2dyYW0gd29u4oCZdCBzdG9wIGV4ZWN1dGluZyBkdXJpbmcgdGhlIGRlbGF5LiBBc3luY2hyb25vdXMgSmF2YVNjcmlwdCB1c2VzIHNvbWV0aGluZyBjYWxsZWQgdGhlIGV2ZW50LWxvb3AuIEFmdGVyIHR3byBzZWNvbmRzLCBkZWxheWVkSGVsbG8oKSBpcyBhZGRlZCB0byBhIGxpbmUgb2YgY29kZSB3YWl0aW5nIHRvIGJlIHJ1bi4gQmVmb3JlIGl0IGNhbiBydW4sIGFueSBzeW5jaHJvbm91cyBjb2RlIGZyb20gdGhlIHByb2dyYW0gd2lsbCBydW4uIE5leHQsIGFueSBjb2RlIGluIGZyb250IG9mIGl0IGluIHRoZSBsaW5lIHdpbGwgcnVuLiBUaGlzIG1lYW5zIGl0IG1pZ2h0IGJlIG1vcmUgdGhhbiB0d28gc2Vjb25kcyBiZWZvcmUgZGVsYXllZEhlbGxvKCkgaXMgYWN0dWFsbHkgZXhlY3V0ZWQuYCksbWR4KCJoMSIseyJpZCI6ImNvbnN0cnVjdGluZy1hc3luY2hyb25vdXMtcHJvbWlzZXMifSxgQ29uc3RydWN0aW5nIGFzeW5jaHJvbm91cyBwcm9taXNlc2ApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgY29uc3QgcmV0dXJuUHJvbWlzZUZ1bmN0aW9uID0gKCkgPT4gewogIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgICBzZXRUaW1lb3V0KCggKSA9PiB7cmVzb2x2ZSgnSSByZXNvbHZlZCEnKX0sIDEwMDApOwogIH0pOwp9OwoKY29uc3QgcHJvbSA9IHJldHVyblByb21pc2VGdW5jdGlvbigpOwpgKSksbWR4KCJoMSIseyJpZCI6ImNvbnN1bWluZy1wcm9taXNlcyJ9LGBDb25zdW1pbmcgUHJvbWlzZXNgKSxtZHgoInAiLG51bGwsYFRoZSBpbml0aWFsIHN0YXRlIG9mIGFuIGFzeW5jaHJvbm91cyBwcm9taXNlIGlzIHBlbmRpbmcsIGJ1dCB3ZSBoYXZlIGEgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzZXR0bGUuIEhvdyBkbyB3ZSB0ZWxsIHRoZSBjb21wdXRlciB3aGF0IHNob3VsZCBoYXBwZW4gdGhlbj8gUHJvbWlzZSBvYmplY3RzIGNvbWUgd2l0aCBhbiBhcHRseSBuYW1lZCAudGhlbigpIG1ldGhvZC5gKSxtZHgoInAiLG51bGwsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LGAudGhlbigpYCksYCBpcyBhIGhpZ2hlci1vcmRlciBmdW5jdGlvbuKAlCBpdCB0YWtlcyB0d28gY2FsbGJhY2sgZnVuY3Rpb25zIGFzIGFyZ3VtZW50cy4gV2UgcmVmZXIgdG8gdGhlc2UgY2FsbGJhY2tzIGFzIGhhbmRsZXJzLiBXaGVuIHRoZSBwcm9taXNlIHNldHRsZXMsIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVyIHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoYXQgc2V0dGxlZCB2YWx1ZS5gKSxtZHgoImgxIix7ImlkIjoib25mdWxmaWxsZWQtYW5kLW9ucmVqZWN0ZWQtZnVuY3Rpb25zIn0sYG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIEZ1bmN0aW9uc2ApLG1keCgicCIsbnVsbCxgVG8gaGFuZGxlIGEg4oCcc3VjY2Vzc2Z1bOKAnSBwcm9taXNlLCBvciBhIHByb21pc2UgdGhhdCByZXNvbHZlZCwgd2UgaW52b2tlIC50aGVuKCkgb24gdGhlIHByb21pc2UsIHBhc3NpbmcgaW4gYSBzdWNjZXNzIGhhbmRsZXIgY2FsbGJhY2sgZnVuY3Rpb25gKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7CiAgcmVzb2x2ZSgnWWF5IScpOwp9KTsKCmNvbnN0IGhhbmRsZVN1Y2Nlc3MgPSAocmVzb2x2ZWRWYWx1ZSkgPT4gewogIGNvbnNvbGUubG9nKHJlc29sdmVkVmFsdWUpOwp9OwoKcHJvbS50aGVuKGhhbmRsZVN1Y2Nlc3MpOyAvLyBQcmludHM6ICdZYXkhJwpgKSksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBsZXQgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICBsZXQgbnVtID0gTWF0aC5yYW5kb20oKTsKICBpZiAobnVtIDwgLjUgKXsKICAgIHJlc29sdmUoJ1lheSEnKTsKICB9IGVsc2UgewogICAgcmVqZWN0KCdPaGhoIG5vb29vIScpOwogIH0KfSk7Cgpjb25zdCBoYW5kbGVTdWNjZXNzID0gKHJlc29sdmVkVmFsdWUpID0+IHsKICBjb25zb2xlLmxvZyhyZXNvbHZlZFZhbHVlKTsKfTsKCmNvbnN0IGhhbmRsZUZhaWx1cmUgPSAocmVqZWN0aW9uUmVhc29uKSA9PiB7CiAgY29uc29sZS5sb2cocmVqZWN0aW9uUmVhc29uKTsKfTsKCnByb20udGhlbihoYW5kbGVTdWNjZXNzLCBoYW5kbGVGYWlsdXJlKTsKYCkpLG1keCgiaDEiLHsiaWQiOiJ1c2luZy1jYXRjaC13aXRoLXByb21pc2VzIn0sYFVzaW5nIGNhdGNoKCkgd2l0aCBQcm9taXNlc2ApLG1keCgicCIsbnVsbCxgT25lIHdheSB0byB3cml0ZSBjbGVhbmVyIGNvZGUgaXMgdG8gZm9sbG93IGEgcHJpbmNpcGxlIGNhbGxlZCBzZXBhcmF0aW9uIG9mIGNvbmNlcm5zLiBTZXBhcmF0aW9uIG9mIGNvbmNlcm5zIG1lYW5zIG9yZ2FuaXppbmcgY29kZSBpbnRvIGRpc3RpbmN0IHNlY3Rpb25zIGVhY2ggaGFuZGxpbmcgYSBzcGVjaWZpYyB0YXNrLiBJdCBlbmFibGVzIHVzIHRvIHF1aWNrbHkgbmF2aWdhdGUgb3VyIGNvZGUgYW5kIGtub3cgd2hlcmUgdG8gbG9vayBpZiBzb21ldGhpbmcgaXNu4oCZdCB3b3JraW5nLmApLG1keCgicCIsbnVsbCxgUmVtZW1iZXIsIGAsbWR4KCJpbmxpbmVDb2RlIix7cGFyZW50TmFtZToicCJ9LGAudGhlbigpYCksYCB3aWxsIHJldHVybiBhIHByb21pc2Ugd2l0aCB0aGUgc2FtZSBzZXR0bGVkIHZhbHVlIGFzIHRoZSBwcm9taXNlIGl0IHdhcyBjYWxsZWQgb24gaWYgbm8gYXBwcm9wcmlhdGUgaGFuZGxlciB3YXMgcHJvdmlkZWQuIFRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzIHVzIHRvIHNlcGFyYXRlIG91ciByZXNvbHZlZCBsb2dpYyBmcm9tIG91ciByZWplY3RlZCBsb2dpYy4gSW5zdGVhZCBvZiBwYXNzaW5nIGJvdGggaGFuZGxlcnMgaW50byBvbmUgLnRoZW4oKSwgd2UgY2FuIGNoYWluIGEgc2Vjb25kIC50aGVuKCkgd2l0aCBhIGZhaWx1cmUgaGFuZGxlciB0byBhIGZpcnN0IC50aGVuKCkgd2l0aCBhIHN1Y2Nlc3MgaGFuZGxlciBhbmQgYm90aCBjYXNlcyB3aWxsIGJlIGhhbmRsZWQuYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBwcm9tCiAgLnRoZW4oKHJlc29sdmVkVmFsdWUpID0+IHsKICAgIGNvbnNvbGUubG9nKHJlc29sdmVkVmFsdWUpOwogIH0pCiAgLnRoZW4obnVsbCwgKHJlamVjdGlvblJlYXNvbikgPT4gewogICAgY29uc29sZS5sb2cocmVqZWN0aW9uUmVhc29uKTsKICB9KTsKYCkpLG1keCgicCIsbnVsbCxgVGhlIC5jYXRjaCgpIGZ1bmN0aW9uIHRha2VzIG9ubHkgb25lIGFyZ3VtZW50LCBvblJlamVjdGVkLiBJbiB0aGUgY2FzZSBvZiBhIHJlamVjdGVkIHByb21pc2UsIHRoaXMgZmFpbHVyZSBoYW5kbGVyIHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSByZWFzb24gZm9yIHJlamVjdGlvbi4gVXNpbmcgLmNhdGNoKCkgYWNjb21wbGlzaGVzIHRoZSBzYW1lIHRoaW5nIGFzIHVzaW5nIGEgLnRoZW4oKSB3aXRoIG9ubHkgYSBmYWlsdXJlIGhhbmRsZXIuYCksbWR4KCJwcmUiLG51bGwsbWR4KCJjb2RlIixfZXh0ZW5kcyh7cGFyZW50TmFtZToicHJlIn0se30pLGBwcm9tCiAgLnRoZW4oKHJlc29sdmVkVmFsdWUpID0+IHsKICAgIGNvbnNvbGUubG9nKHJlc29sdmVkVmFsdWUpOwogIH0pCiAgLmNhdGNoKChyZWplY3Rpb25SZWFzb24pID0+IHsKICAgIGNvbnNvbGUubG9nKHJlamVjdGlvblJlYXNvbik7CiAgfSk7CmApKSxtZHgoImgxIix7ImlkIjoicmVmcmFjdGVkLWNvZGUifSxgUmVmcmFjdGVkIGNvZGVgKSxtZHgoInByZSIsbnVsbCxtZHgoImNvZGUiLF9leHRlbmRzKHtwYXJlbnROYW1lOiJwcmUifSx7fSksYCBjaGVja0ludmVudG9yeShvcmRlcikKICAgIC50aGVuKGhhbmRsZVN1Y2Nlc3MpCiAgICAuY2F0Y2goaGFuZGxlRmFpbHVyZSk7CmApKSxtZHgoImgxIix7ImlkIjoiY2hhaW5pbmctcHJvbWlzZXMifSxgQ2hhaW5pbmcgUHJvbWlzZXNgKSxtZHgoInAiLG51bGwsYE9uZSBjb21tb24gcGF0dGVybiB3ZeKAmWxsIHNlZSB3aXRoIGFzeW5jaHJvbm91cyBwcm9ncmFtbWluZyBpcyBtdWx0aXBsZSBvcGVyYXRpb25zIHdoaWNoIGRlcGVuZCBvbiBlYWNoIG90aGVyIHRvIGV4ZWN1dGUgb3IgdGhhdCBtdXN0IGJlIGV4ZWN1dGVkIGluIGEgY2VydGFpbiBvcmRlci4gV2UgbWlnaHQgbWFrZSBvbmUgcmVxdWVzdCB0byBhIGRhdGFiYXNlIGFuZCB1c2UgdGhlIGRhdGEgcmV0dXJuZWQgdG8gdXMgdG8gbWFrZSBhbm90aGVyIHJlcXVlc3QgYW5kIHNvIG9uIWApLG1keCgicHJlIixudWxsLG1keCgiY29kZSIsX2V4dGVuZHMoe3BhcmVudE5hbWU6InByZSJ9LHt9KSxgZmlyc3RQcm9taXNlRnVuY3Rpb24oKQoudGhlbigoZmlyc3RSZXNvbHZlVmFsKSA9PiB7CiAgcmV0dXJuIHNlY29uZFByb21pc2VGdW5jdGlvbihmaXJzdFJlc29sdmVWYWwpOwp9KQoudGhlbigoc2Vjb25kUmVzb2x2ZVZhbCkgPT4gewogIGNvbnNvbGUubG9nKHNlY29uZFJlc29sdmVWYWwpOwp9KTsKYCkpKTt9O01EWENvbnRlbnQuaXNNRFhDb21wb25lbnQ9dHJ1ZTs="},{"version":3,"sources":["/Users/jack/Documents/GitHub/Docs/docs/js/adva/promises.md"],"names":["React","mdx","frontMatter","metadata","rightToc","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["\n  import React from 'react';\n  import { mdx } from '@mdx-js/react';\n\n  export const frontMatter = {};\nexport const metadata = {\n  \"id\": \"js/adva/promises\",\n  \"title\": \"promises\",\n  \"description\": \"# Promises in Js\",\n  \"source\": \"@site/docs/js/adva/promises.md\",\n  \"permalink\": \"/docs/js/adva/promises\"\n};\n  /* @jsx mdx */\n\nexport const rightToc = [];\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  rightToc\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <h1 {...{\n      \"id\": \"promises-in-js\"\n    }}>{`Promises in Js`}</h1>\n    <p>{`An asynchronous operation is one that allows the computer to “move on” to other tasks while waiting for the asynchronous operation to complete. Asynchronous programming means that time-consuming operations don’t have to bring everything else in our programs to a halt.`}</p>\n    <p>{`Operations like making a network request or querying a database can be time-consuming, but JavaScript allows us to execute other tasks while awaiting their completion.`}</p>\n    <h1 {...{\n      \"id\": \"what-is-promise\"\n    }}>{`What is promise?`}</h1>\n    <p>{`Promises are objects that represent the eventual outcome of an asynchronous operation.`}</p>\n    <p>{`They come in three forms: Pending / furfilled / rejected`}</p>\n    <p>{`Pending: The initial state— the operation has not completed yet.`}</p>\n    <p>{`Fulfilled: The operation has completed successfully and the promise now has a resolved value. For example, a request’s promise might resolve with a JSON object as its value.`}</p>\n    <p>{`Rejected: The operation has failed and the promise has a reason for the failure. This reason is usually an Error of some kind.`}</p>\n    <h1 {...{\n      \"id\": \"constructing-a-promise-object\"\n    }}>{`Constructing a promise Object`}</h1>\n    <p>{`To create a new Promise object, we use the new keyword and the Promise constructor method.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`const executorFunction = (resolve, reject) => { };\nconst myFirstPromise = new Promise(executorFunction);\n`}</code></pre>\n    <p>{`The Promise constructor method takes a function parameter called the executor function which runs automatically when the constructor is called. The executor function generally starts an asynchronous operation and dictates how the promise should be settled.`}</p>\n    <h1 {...{\n      \"id\": \"an-example-executor-function-in-a-promise-constructor\"\n    }}>{`An example executor function in a Promise constructor`}</h1>\n    <pre><code parentName=\"pre\" {...{}}>{`const executorFunction = (resolve, reject) => {\n  if (someCondition) {\n      resolve('I resolved!');\n  } else {\n      reject('I rejected!'); \n  }\n}\nconst myFirstPromise = new Promise(executorFunction);\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`const inventory = {\n  sunglasses: 1900,\n  pants: 1088,\n  bags: 1344\n};\n\n// Write your code below:\nconst myExecutor = (resolve, reject) => {\n  if (inventory.sunglasses > 0) {\n    resolve('Sunglasses order processed.');\n  } else {\n    reject('That item is sold out.');\n  }\n}\n\nconst orderSunglasses = () => new Promise(myExecutor);\nconst orderPromise = orderSunglasses();\n\nconsole.log(orderPromise);\n`}</code></pre>\n    <h1 {...{\n      \"id\": \"the-node-settimeout-function\"\n    }}>{`The Node setTimeout() Function`}</h1>\n    <p>{`Knowing how to construct a promise is useful, but most of the time, knowing how to consume, or use, promises will be key. Rather than constructing promises, you’ll be handling Promise objects returned to you as the result of an asynchronous operation. These promises will start off pending but settle eventually.`}</p>\n    <p><inlineCode parentName=\"p\">{`setTimeout()`}</inlineCode>{` is a Node API (a comparable API is provided by web browsers) that uses callback functions to schedule tasks to be performed after a delay. setTimeout() has two parameters: a callback function and a delay in milliseconds`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`const delayedHello = () => {\n  console.log('Hi! This is an asynchronous greeting!');\n};\n\nsetTimeout(delayedHello, 2000);\n`}</code></pre>\n    <p>{`This delay is performed asynchronously—the rest of our program won’t stop executing during the delay. Asynchronous JavaScript uses something called the event-loop. After two seconds, delayedHello() is added to a line of code waiting to be run. Before it can run, any synchronous code from the program will run. Next, any code in front of it in the line will run. This means it might be more than two seconds before delayedHello() is actually executed.`}</p>\n    <h1 {...{\n      \"id\": \"constructing-asynchronous-promises\"\n    }}>{`Constructing asynchronous promises`}</h1>\n    <pre><code parentName=\"pre\" {...{}}>{`const returnPromiseFunction = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(( ) => {resolve('I resolved!')}, 1000);\n  });\n};\n\nconst prom = returnPromiseFunction();\n`}</code></pre>\n    <h1 {...{\n      \"id\": \"consuming-promises\"\n    }}>{`Consuming Promises`}</h1>\n    <p>{`The initial state of an asynchronous promise is pending, but we have a guarantee that it will settle. How do we tell the computer what should happen then? Promise objects come with an aptly named .then() method.`}</p>\n    <p><inlineCode parentName=\"p\">{`.then()`}</inlineCode>{` is a higher-order function— it takes two callback functions as arguments. We refer to these callbacks as handlers. When the promise settles, the appropriate handler will be invoked with that settled value.`}</p>\n    <h1 {...{\n      \"id\": \"onfulfilled-and-onrejected-functions\"\n    }}>{`onFulfilled and onRejected Functions`}</h1>\n    <p>{`To handle a “successful” promise, or a promise that resolved, we invoke .then() on the promise, passing in a success handler callback function`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`const prom = new Promise((resolve, reject) => {\n  resolve('Yay!');\n});\n\nconst handleSuccess = (resolvedValue) => {\n  console.log(resolvedValue);\n};\n\nprom.then(handleSuccess); // Prints: 'Yay!'\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`let prom = new Promise((resolve, reject) => {\n  let num = Math.random();\n  if (num < .5 ){\n    resolve('Yay!');\n  } else {\n    reject('Ohhh noooo!');\n  }\n});\n\nconst handleSuccess = (resolvedValue) => {\n  console.log(resolvedValue);\n};\n\nconst handleFailure = (rejectionReason) => {\n  console.log(rejectionReason);\n};\n\nprom.then(handleSuccess, handleFailure);\n`}</code></pre>\n    <h1 {...{\n      \"id\": \"using-catch-with-promises\"\n    }}>{`Using catch() with Promises`}</h1>\n    <p>{`One way to write cleaner code is to follow a principle called separation of concerns. Separation of concerns means organizing code into distinct sections each handling a specific task. It enables us to quickly navigate our code and know where to look if something isn’t working.`}</p>\n    <p>{`Remember, `}<inlineCode parentName=\"p\">{`.then()`}</inlineCode>{` will return a promise with the same settled value as the promise it was called on if no appropriate handler was provided. This implementation allows us to separate our resolved logic from our rejected logic. Instead of passing both handlers into one .then(), we can chain a second .then() with a failure handler to a first .then() with a success handler and both cases will be handled.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`prom\n  .then((resolvedValue) => {\n    console.log(resolvedValue);\n  })\n  .then(null, (rejectionReason) => {\n    console.log(rejectionReason);\n  });\n`}</code></pre>\n    <p>{`The .catch() function takes only one argument, onRejected. In the case of a rejected promise, this failure handler will be invoked with the reason for rejection. Using .catch() accomplishes the same thing as using a .then() with only a failure handler.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`prom\n  .then((resolvedValue) => {\n    console.log(resolvedValue);\n  })\n  .catch((rejectionReason) => {\n    console.log(rejectionReason);\n  });\n`}</code></pre>\n    <h1 {...{\n      \"id\": \"refracted-code\"\n    }}>{`Refracted code`}</h1>\n    <pre><code parentName=\"pre\" {...{}}>{` checkInventory(order)\n    .then(handleSuccess)\n    .catch(handleFailure);\n`}</code></pre>\n    <h1 {...{\n      \"id\": \"chaining-promises\"\n    }}>{`Chaining Promises`}</h1>\n    <p>{`One common pattern we’ll see with asynchronous programming is multiple operations which depend on each other to execute or that must be executed in a certain order. We might make one request to a database and use the data returned to us to make another request and so on!`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`firstPromiseFunction()\n.then((firstResolveVal) => {\n  return secondPromiseFunction(firstResolveVal);\n})\n.then((secondResolveVal) => {\n  console.log(secondResolveVal);\n});\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n  "]}]}
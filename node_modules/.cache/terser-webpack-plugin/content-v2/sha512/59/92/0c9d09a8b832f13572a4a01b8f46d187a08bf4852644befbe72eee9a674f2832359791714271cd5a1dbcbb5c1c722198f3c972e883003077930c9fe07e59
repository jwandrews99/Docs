{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{145:function(e,t,r){\"use strict\";r.r(t),r.d(t,\"frontMatter\",(function(){return a})),r.d(t,\"metadata\",(function(){return i})),r.d(t,\"rightToc\",(function(){return u})),r.d(t,\"default\",(function(){return l}));var n=r(1),o=r(6),s=(r(0),r(152)),a={id:\"express-routers\",title:\"Express.JS() Routers\"},i={id:\"back-end/ExpressJS/express-routers\",title:\"Express.JS() Routers\",description:\"# This File Is Too Big!\",source:\"@site/docs/back-end/ExpressJS/Routers.md\",permalink:\"/docs/back-end/ExpressJS/express-routers\"},u=[],c={rightToc:u};function l(e){var t=e.components,r=Object(o.a)(e,[\"components\"]);return Object(s.b)(\"wrapper\",Object(n.a)({},c,r,{components:t,mdxType:\"MDXLayout\"}),Object(s.b)(\"h1\",{id:\"this-file-is-too-big\"},\"This File Is Too Big!\"),Object(s.b)(\"p\",null,\"Your Expressions/Animals routes are all working well, and our machine is fully functional! Our app.js file, however, is getting quite long and hard to read. It\\u2019s easy to imagine that as we add functionality to an application, this file would get long and cumbersome.\"),Object(s.b)(\"p\",null,\"Luckily, Express provides functionality to alleviate this problem: Routers. Routers are mini versions of Express applications \\u2014 they provide functionality for handling route matching, requests, and sending responses, but they do not start a separate server or listen on their own ports. Routers use all the .get(), .put(), .post(), and .delete() routes that you know and love.\"),Object(s.b)(\"p\",null,\"In this lesson, we will use Routers to clean up our code and separate our application into a file to handle all routes, and another to handle all the other routes.\"),Object(s.b)(\"h1\",{id:\"expressrouter\"},\"Express.Router\"),Object(s.b)(\"p\",null,\"An Express router provides a subset of Express methods. To create an instance of one, we invoke the .Router() method on the top-level Express import.\"),Object(s.b)(\"p\",null,\"To use a router, we mount it at a certain path using app.use() and pass in the router as the second argument. This router will now be used for all paths that begin with that path segment. To create a router to handle all requests beginning with /monsters, the code would look like this:\"),Object(s.b)(\"pre\",null,Object(s.b)(\"code\",Object(n.a)({parentName:\"pre\"},{}),\"const express = require('express');\\nconst app = express();\\n\\nconst monsters = {\\n  '1': {\\n    name: 'godzilla',\\n    age: 250000000\\n  },\\n  '2': {\\n    Name: 'manticore',\\n    age: 21\\n  }\\n}\\n\\nconst monstersRouter = express.Router();\\n\\napp.use('/monsters', monstersRouter);\\n\\nmonstersRouter.get('/:id', (req, res, next) => {\\n  const monster = monsters[req.params.id];\\n  If (monster) {\\n    res.send(monster);\\n  } else {\\n    res.status(404).send();\\n  }\\n});\\n\")),Object(s.b)(\"p\",null,\"Inside the monstersRouter, all matching routes are assumed to have /monsters prepended, as it is mounted at that path. monstersRouter.get('/:id') matches the full path /monsters/:id.\"),Object(s.b)(\"p\",null,\"When a GET /monsters/1 request arrives, Express matches /monsters in app.use() because the beginning of the path ('/monsters') matches. Express\\u2019 route-matching algorithm enters the monstersRouter\\u2018s routes to search for full path matches. Since monstersRouter.get('/:id) is mounted at /monsters, the two paths together match the entire request path (/monsters/1), so the route matches and the callback is invoked. The 'godzilla' monster is fetched from the monsters array and sent back.\"))}l.isMDXComponent=!0},152:function(e,t,r){\"use strict\";r.d(t,\"a\",(function(){return p})),r.d(t,\"b\",(function(){return h}));var n=r(0),o=r.n(n);function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function u(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=o.a.createContext({}),l=function(e){var t=o.a.useContext(c),r=t;return e&&(r=\"function\"==typeof e?e(t):i({},t,{},e)),r},p=function(e){var t=l(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:\"code\",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=Object(n.forwardRef)((function(e,t){var r=e.components,n=e.mdxType,s=e.originalType,a=e.parentName,c=u(e,[\"components\",\"mdxType\",\"originalType\",\"parentName\"]),p=l(r),m=n,h=p[\"\".concat(a,\".\").concat(m)]||p[m]||d[m]||s;return r?o.a.createElement(h,i({ref:t},c,{components:r})):o.a.createElement(h,i({ref:t},c))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if(\"string\"==typeof e||n){var s=r.length,a=new Array(s);a[0]=m;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i.mdxType=\"string\"==typeof e?e:n,a[1]=i;for(var c=2;c<s;c++)a[c]=r[c];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,r)}m.displayName=\"MDXCreateElement\"}}]);","extractedComments":[]}